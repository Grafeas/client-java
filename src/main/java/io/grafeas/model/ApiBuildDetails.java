/*
 * Grafeas API
 * An API to insert and retrieve annotations on cloud artifacts.
 *
 * OpenAPI spec version: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.grafeas.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.grafeas.model.ApiBuildProvenance;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * Message encapsulating build provenance details.
 */
@ApiModel(description = "Message encapsulating build provenance details.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-06-04T13:20:14.121-07:00")
public class ApiBuildDetails {
  @SerializedName("provenance")
  private ApiBuildProvenance provenance = null;

  @SerializedName("provenance_bytes")
  private String provenanceBytes = null;

  public ApiBuildDetails provenance(ApiBuildProvenance provenance) {
    this.provenance = provenance;
    return this;
  }

   /**
   * Get provenance
   * @return provenance
  **/
  @ApiModelProperty(value = "")
  public ApiBuildProvenance getProvenance() {
    return provenance;
  }

  public void setProvenance(ApiBuildProvenance provenance) {
    this.provenance = provenance;
  }

  public ApiBuildDetails provenanceBytes(String provenanceBytes) {
    this.provenanceBytes = provenanceBytes;
    return this;
  }

   /**
   * Serialized JSON representation of the provenance, used in generating the &#x60;BuildSignature&#x60; in the corresponding Result. After verifying the signature, &#x60;provenance_bytes&#x60; can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification.  The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
   * @return provenanceBytes
  **/
  @ApiModelProperty(value = "Serialized JSON representation of the provenance, used in generating the `BuildSignature` in the corresponding Result. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification.  The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.")
  public String getProvenanceBytes() {
    return provenanceBytes;
  }

  public void setProvenanceBytes(String provenanceBytes) {
    this.provenanceBytes = provenanceBytes;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiBuildDetails apiBuildDetails = (ApiBuildDetails) o;
    return Objects.equals(this.provenance, apiBuildDetails.provenance) &&
        Objects.equals(this.provenanceBytes, apiBuildDetails.provenanceBytes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(provenance, provenanceBytes);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiBuildDetails {\n");
    
    sb.append("    provenance: ").append(toIndentedString(provenance)).append("\n");
    sb.append("    provenanceBytes: ").append(toIndentedString(provenanceBytes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

